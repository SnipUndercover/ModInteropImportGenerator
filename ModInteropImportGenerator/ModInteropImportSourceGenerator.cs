using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using JetBrains.Annotations;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using ModInteropImportGenerator.Helpers;

namespace ModInteropImportGenerator;

// see https://github.com/dotnet/roslyn/blob/main/docs/features/incremental-generators.md
[Generator]
public class ModInteropImportSourceGenerator : IIncrementalGenerator
{
    private const string GenerateImportsAttributeTypeName = "GenerateImportsAttribute";
    private const string GenerateImportsAttributeNamespace = "ModInteropImportGenerator";

    [LanguageInjection("C#")]
    private const string GenerateImportsAttributeDefinition =
        $$"""
          // <auto-generated />
          using System;

          namespace {{GenerateImportsAttributeNamespace}};

          /// <summary>
          ///   Generate ModInterop fields based on the method names and signatures.
          /// </summary>
          /// <param name="modInteropName">
          ///   The ModExportName from which to import.
          /// </param>
          [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
          [Microsoft.CodeAnalysis.Embedded]
          internal class {{GenerateImportsAttributeTypeName}}(string modInteropName) : Attribute
          {
              /// <summary>
              ///   The ModExportName whose methods should be imported.
              /// </summary>
              public string ModInteropName { get; } = modInteropName;

              /// <summary>
              ///   Whether this import is a required dependency, and should crash the game
              ///   if the import did not load successfully.
              /// </summary>
              public bool RequiredDependency { get; set; } = false;
          }
          """;

    private const string GenerateImportsAttributeFqn
        = $"{GenerateImportsAttributeNamespace}.{GenerateImportsAttributeTypeName}";

    [LanguageInjection("C#")]
    private const string EmbeddedAttributeDefinition =
        """
        using System;

        namespace Microsoft.CodeAnalysis;

        [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Enum | AttributeTargets.Delegate)]
        internal sealed class EmbeddedAttribute : Attribute;
        """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // add the attribute so that IDEs can pick up on it and let the user use it
        context.RegisterPostInitializationOutput(ctx =>
        {
            // ctx.AddEmbeddedAttributeDefinition() is available in compiler version 3.14.0, but we're using 3.12.0...
            ctx.AddSource(
                "EmbeddedAttribute.g.cs",
                SourceText.From(EmbeddedAttributeDefinition, Encoding.UTF8));
            ctx.AddSource(
                $"{GenerateImportsAttributeTypeName}.g.cs",
                SourceText.From(GenerateImportsAttributeDefinition, Encoding.UTF8));
        });

        // get our syntax provider, filtering only for classes annotated with the [GenerateImports] attribute.
        // only filtered syntax nodes can trigger code generation.
        // there's a convenient ForAttributeWithMetadataName which is
        var provider = context.SyntaxProvider.ForAttributeWithMetadataName(
            GenerateImportsAttributeFqn,
            static (node, _) => node is ClassDeclarationSyntax, // we can return `true` here but let's be sure
            static (syntaxContext, _) => GetClassDeclarationForSourceGen(syntaxContext))
            .Where(t => t.importMeta is not null)
            .Select((t, _) => (t.classDeclaration, importMeta: t.importMeta!.Value));

        // register the source code generator
        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(provider.Collect()),
            (ctx, t) => GenerateCode(ctx, t.Left, t.Right));
    }

    /// <summary>
    ///   Checks whether the Node is annotated with the [<see cref="GenerateImportsAttribute"/>] attribute
    ///   and maps syntax context to the specific node type (ClassDeclarationSyntax).
    /// </summary>
    /// <param name="context">Syntax context, based on CreateSyntaxProvider predicate</param>
    /// <returns>The specific cast and whether the attribute was found.</returns>
    private static (ClassDeclarationSyntax classDeclaration, ModImportMetadata? importMeta)
        GetClassDeclarationForSourceGen(GeneratorAttributeSyntaxContext context)
    {
        // we already know this is a ClassDeclarationSyntax since this attribute can only be added to types
        var classDeclaration = (ClassDeclarationSyntax)context.TargetNode;

        Debug.WriteLine($"Checking declaration of class \"{classDeclaration.Identifier.Text}\"...");

        AttributeData? attribute = context.Attributes
            .FirstOrDefault(attr => attr.AttributeClass?.ToDisplayString() == GenerateImportsAttributeFqn);

        if (attribute is null)
            throw new InvalidOperationException($"Cannot find \"{GenerateImportsAttributeFqn}\" attribute!");
        Debug.WriteLine($"Found attribute \"{GenerateImportsAttributeFqn}\".");

        (ClassDeclarationSyntax classDeclaration, ModImportMetadata? importMeta) failedDeclaration
            = (classDeclaration, null);

        var ctorArgs = attribute.ConstructorArguments;
        if (ctorArgs.Length < 1)
        {
            Debug.WriteLine($"\"{GenerateImportsAttributeTypeName}\" argument count is less than 1, skipping.");
            return failedDeclaration;
        }

        var modImportNameArgument = ctorArgs[0];
        if (modImportNameArgument.Kind == TypedConstantKind.Error)
        {
            Debug.WriteLine($"\"{GenerateImportsAttributeTypeName}\" name argument is in error, skipping.");
            return failedDeclaration;
        }

        if (modImportNameArgument.Value is not string modImportName)
        {
            Debug.WriteLine($"\"{GenerateImportsAttributeTypeName}\" name is not a string, skipping.");
            return failedDeclaration;
        }

        Debug.WriteLine($"Found mod import name: \"{modImportName}\"");

        var requiredDependency = false;
        var namedArguments = attribute.NamedArguments.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
        if (namedArguments.TryGetValue("RequiredDependency", out var requiredDependencyArgument))
        {
            if (requiredDependencyArgument.Kind == TypedConstantKind.Error)
            {
                Debug.WriteLine($"\"{GenerateImportsAttributeTypeName}\" \"RequiredDependency\" argument is in error.");
                return failedDeclaration;
            }

            if (requiredDependencyArgument.Value is not bool requiredDependencyValue)
            {
                Debug.WriteLine("Required dependency argument is not a bool, skipping.");
                return failedDeclaration;
            }

            requiredDependency = requiredDependencyValue;
            Debug.WriteLine($"RequiredDependency defined as {requiredDependency}.");
        }
        else
            Debug.WriteLine("RequiredDependency not defined, treating as false.");

        return (classDeclaration, new ModImportMetadata(modImportName, requiredDependency));
    }

    private static void GenerateCode(
        SourceProductionContext context,
        Compilation compilation,
        ImmutableArray<(ClassDeclarationSyntax classDeclaration, ModImportMetadata importMeta)> modImportDeclarations)
    {
        // go through all the filtered class declarations
        foreach ((ClassDeclarationSyntax classDeclaration, ModImportMetadata importMeta) in modImportDeclarations)
        {
            // we need to get semantic model of the class to retrieve metadata
            SemanticModel model = compilation.GetSemanticModel(classDeclaration.SyntaxTree);

            // symbols allow us to get the compile-time information
            if (model.GetDeclaredSymbol(classDeclaration) is not INamedTypeSymbol classSymbol)
                continue;

            MethodHelpers.ClearGeneratedNameCache();
            SimpleSourceGenerator sourceGen = new(classDeclaration, compilation, importMeta);

            List<IMethodSymbol> methodsToImport = classSymbol.GetMembers()
                .OfType<IMethodSymbol>()
                .Where(m => m.IsPartialDefinition && m.PartialImplementationPart is null)
                .ToList();

            sourceGen.AddUsings("System", "System.Diagnostics", "MonoMod.ModInterop");

            sourceGen.WriteLine($"public static partial class {sourceGen.ClassName}");
            using (sourceGen.UseCodeBlock())
            {
                SourceGenerators.GenerateMethodImplementations(sourceGen, methodsToImport);
                sourceGen.WriteLine();
                SourceGenerators.GenerateLoadMethod(sourceGen, methodsToImport);
            }
            sourceGen.WriteLine();

            sourceGen.WriteLine($"[ModImportName({SourceGenerators.GeneratedModImportClassName}.ImportName)]");
            sourceGen.WriteLine($"file class {SourceGenerators.GeneratedModImportClassName}");
            using (sourceGen.UseCodeBlock())
            {
                sourceGen.WriteLine($"public const string ImportName = \"{importMeta.ImportName}\";");
                sourceGen.WriteLine();
                sourceGen.WriteLine("// Fields are initialized by ModInterop");
                sourceGen.WriteLine("#pragma warning disable CS0649 // Field is never assigned to, and will always have its default value");
                sourceGen.WriteLine();
                SourceGenerators.GenerateImportFields(sourceGen, methodsToImport);
                sourceGen.WriteLine();
                sourceGen.WriteLine("#pragma warning restore CS0649 // Field is never assigned to, and will always have its default value");
            }

            // add the source code to the compilation
            context.AddSource($"{sourceGen.ClassName}.g.cs", SourceText.From(sourceGen.Generate(), Encoding.UTF8));
        }
    }
}
