using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ModInteropImportGenerator;

public class SimpleSourceGenerator
{
    private readonly SortedSet<string> Usings = new(StringComparer.Ordinal);
    private readonly StringBuilder SourceCode = new();
    private bool ShouldIndentLine = true;

    private int _IndentLevel;
    public int IndentLevel
    {
        get => _IndentLevel;
        set => _IndentLevel = value < 0 ? 0 : value;
    }

    public readonly ClassDeclarationSyntax ClassDeclaration;
    public readonly INamedTypeSymbol ClassSymbol;
    public readonly ModImportMetadata ImportMeta;
    public readonly SemanticModel SemanticModel;

    public readonly string Namespace;
    public readonly string ClassName;

    public SimpleSourceGenerator(ClassDeclarationSyntax classDeclaration,
        Compilation compilation,
        ModImportMetadata importMeta)
    {
        ClassDeclaration = classDeclaration;
        ImportMeta = importMeta;
        SemanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);

        if (SemanticModel.GetDeclaredSymbol(ClassDeclaration) is not { } typeSymbol)
            throw new InvalidOperationException(
                $"Attempted to create a source generator for something that isn't an {nameof(INamedTypeSymbol)}.");

        ClassSymbol = typeSymbol;
        Namespace = typeSymbol.ContainingNamespace.ToDisplayString();
        ClassName = classDeclaration.Identifier.Text;
    }

    public SimpleSourceGenerator AddUsings(params IEnumerable<string> usingNamespaces)
    {
        foreach (string @namespace in usingNamespaces)
            Usings.Add(@namespace);
        return this;
    }

    public bool TryAddUsingFor(INamespaceSymbol @namespace)
        => Usings.Add(@namespace.ToDisplayString());

    public bool TryAddUsingFor(ITypeSymbol type)
        => type.ContainingNamespace is { } @namespace && TryAddUsingFor(@namespace);

    public SimpleSourceGenerator WriteLine()
    {
        if (ShouldIndentLine)
            WriteIndent();
        SourceCode.AppendLine();
        ShouldIndentLine = true;
        return this;
    }

    public SimpleSourceGenerator WriteLine(string line)
    {
        if (ShouldIndentLine)
            WriteIndent();
        SourceCode.AppendLine(line);
        ShouldIndentLine = true;
        return this;
    }

    public SimpleSourceGenerator WriteLine(char c)
    {
        if (ShouldIndentLine)
            WriteIndent();
        SourceCode.Append(c).AppendLine();
        ShouldIndentLine = true;
        return this;
    }

    public SimpleSourceGenerator Write(string line)
    {
        if (ShouldIndentLine)
            WriteIndent();
        SourceCode.Append(line);
        return this;
    }

    public SimpleSourceGenerator Write(char c)
    {
        if (ShouldIndentLine)
            WriteIndent();
        SourceCode.Append(c);
        return this;
    }

    public string Generate()
    {
        return $"""
                // <auto-generated />
                {string.Join("\n", Usings.Select(usingNamespace => $"using {usingNamespace};"))}

                namespace {Namespace};

                {SourceCode}
                """;
    }

    public SimpleSourceGenerator Indent(int indentCount = 1)
    {
        IndentLevel += indentCount;
        return this;
    }

    public SimpleSourceGenerator Dedent(int dedentCount = 1)
    {
        IndentLevel -= dedentCount;
        return this;
    }

    public IndentContext UseIndent(int indentCount = 1)
        => new(this, indentCount);

    public IndentedCodeBlockContext UseCodeBlock(int indentCount = 1, bool withSemicolon = false)
        => new(this, indentCount, withSemicolon);

    private void WriteIndent()
    {
        ShouldIndentLine = false;
        if (IndentLevel <= 0)
            return;

        for (int i = 0; i < IndentLevel; i++)
        for (int j = 0; j < 4; j++)
            SourceCode.Append(' ');
    }

    public ref struct IndentContext : IDisposable
    {
        private readonly SimpleSourceGenerator SourceGen;
        private readonly int IndentCount;

        private bool Disposed;

        public IndentContext(SimpleSourceGenerator sourceGen, int indentCount)
        {
            SourceGen = sourceGen;
            IndentCount = indentCount;

            sourceGen.IndentLevel += indentCount;
        }

        public void Dispose()
        {
            if (Disposed)
                throw new ObjectDisposedException(nameof(IndentContext));

            Disposed = true;
            SourceGen.IndentLevel -= IndentCount;
        }
    }

    public ref struct IndentedCodeBlockContext : IDisposable
    {
        private readonly SimpleSourceGenerator SourceGen;
        private readonly int IndentCount;
        private readonly bool WithSemicolon;

        private bool Disposed;

        public IndentedCodeBlockContext(SimpleSourceGenerator sourceGen, int indentCount, bool withSemicolon)
        {
            SourceGen = sourceGen;
            IndentCount = indentCount;
            WithSemicolon = withSemicolon;

            sourceGen.WriteLine('{');
            sourceGen.IndentLevel += indentCount;
        }

        public void Dispose()
        {
            if (Disposed)
                throw new ObjectDisposedException(nameof(IndentedCodeBlockContext));

            Disposed = true;
            SourceGen.IndentLevel -= IndentCount;
            SourceGen.Write('}');
            if (WithSemicolon)
                SourceGen.Write(';');
            SourceGen.WriteLine();
        }
    }
}
